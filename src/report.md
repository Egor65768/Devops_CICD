## Part 1. Настройка gitlab-runner

1) Поднимим виртуальную машину Ubuntu Server 22.04 LTS.

![linux](./Sreen/screen1.png)

- Для удобства подключусь к Виртуальной машине по shh с помощью клиента OpenSSH
- Для этого я изменю тип подключения с «NAT» на «Сетевой мост» и с помощью команды ssh user@ip_user подключусь

![linux](./Sreen/screen2.png)

![linux](./Sreen/screen2.1.png)

2) Скачаю и установлю на виртуальную машину gitlab-runner.

- curl -L https://packages.gitlab.com/install/repositories/runner gitlab-runner/script.deb.sh | sudo bash с помощью этой команды скачаю скрипт, который автоматически добавит репозиторий GitLab Runner в мою систему

![linux](./Sreen/screen3.png)

- устанвоим gitlab-runner

![linux](./Sreen/screen4.png)

3) запустим gitlab-runner и зарегистрируем его для использования в текущем проекте (DO6_CICD).

- для регистрации выполню команду: sudo gitlab-runner register

- ввожу туда токе и url указаный на гите 

- заполняю требующиеся поля

![linux](./Sreen/screen5.png)

- проверю что гитлаб раннер установлен и работает 

![linux](./Sreen/screen6.png)

![linux](./Sreen/screen7.png)

## Part 2. Сборка

1) Напишим этап для CI по сборке приложений из проекта C3_SimpleBashUtils.

- Добавим файл .gitlab-ci.yml в корневую часть проекта

![linux](./Sreen/screen8.png)

- tags: [build] указываем теги по умолчанию
- stages определяет этапы работы CI в нашем случае определен только один этап build
- build_stage: - это название задачи, которая принадлежит этапу build
- далее указывается список команд 
- artifacts: - определяет атефакты, мы указываем путь где они будут храниться и срок хранения (30 дней)

- пайплайн фейлится

![linux](./Sreen/screen9.png)

![linux](./Sreen/screen10.png)

- судя по выводу он фейлится из-за того что на виртуалке у нас не стоит make.
- устанавливаю на виртуалку make и gcc 

![linux](./Sreen/screen11.png)

![linux](./Sreen/screen12.png)

- пайплайн успешно отрабатывает

## Part 3. Тест кодстайла

1) Напишим этап для CI, который запускает скрипт кодстайла (clang-format).

- добавим в файл .gitlab-ci.yml следующий код

![linux](./Sreen/screen13.png)

- style_stage: - это название задачи, которая принадлежит этапу style
- добавили скрипт на проверку стиля файлов с расширение .c и .h в директориях cat и grep
- Флаг Werror добавил для того что бы пайплайн фейлился если тест на стиль не прошел 

2) Выполним проеверку корректности работы

- сделаем специально стилевые ошибки в файлах в директории grep

![linux](./Sreen/screen14.png)

- видим что пайплайн успешно зафейлился и вывел ошибки 

![linux](./Sreen/screen15.png)

![linux](./Sreen/screen16.png)

- исправляем ошибки и заново запускаем пайплайн

![linux](./Sreen/screen17.png)

![linux](./Sreen/screen18.png)

- видим что все прошло успешно 

## Part 4. Интеграционные тесты

1) Напишим этап для CI, который запускает интеграционные тесты из проекта.

- Добавим стадия тестов 

![linux](./Sreen/screen19.png)

- ключ needs используется для указания на зависимость этой задачи от успешного завершения предыдущих задач (build_stage и style_stage). 
- в скриптах мы сначала запускаем тесты grep и их вывод записываем в output_grep, затем с помощью grep в выводе находим последнюю строку с результатами и записываем число проваленных тестов в переменную fail_count_grep. По аналогии действуем с тестами для cat. Затем мы проверяем количество ошибок в cat и grep. Если ошибки есть то выводим информацию о их количестве и возвращаем ошибку 1, тем самым фейля пайплайн.

![linux](./Sreen/screen20.png)

![linux](./Sreen/screen21.png)

- видно что без ошибок все работает

- попробую добавить ошибку в grep

![linux](./Sreen/screen22.png)

![linux](./Sreen/screen23.png)

![linux](./Sreen/screen24.png)

- видим что прайплайн успешно фейлится 

## Part 5. Этап деплоя

1) Поднимаем вторую виртуальную машину Ubuntu Server 22.04 LTS.

![linux](./Sreen/screen25.png)

- Для удобства подключусь к Виртуальной машине по shh с помощью клиента OpenSSH
- Для этого я изменю тип подключения с «NAT» на «Сетевой мост» и с помощью команды ssh user@ip_user подключусь. ip_user можно узнать с помощью команды ifconfig

2) Настраиваем SSH и SCP для работы без пароля

- Вместо пароля будем использовать пару ключей шифрования, чтобы сервер-источник файла и сервер-получатель файла знали пользователя и не спрашивали пароль. На сервере-источнике для генерации публичной и приватной пары ключей RSA под нужным нам пользователем (в нашем случае под пользователем gitlab-runner, так как под ним будет происходить копированеи в CICD) выполняем команду: shh-keygen.

- Затем выполним команду scp ~/.ssh/id_rsa.pub deploy@192.168.1.104:~/.ssh/authorized_keys. Эта команда, предназначена для копирования публичного SSH ключа в файл authorized_keys на удалённом сервере с IP адресом 192.168.1.104 (это позволит подключаться к серверу без ввода пароля)

![linux](./Sreen/screen26.png)

![linux](./Sreen/screen27.png)

3) Напишим скрипт, который копирует файлы на вторую виртуалку 

![linux](./Sreen/screen28.png)

4) Вносим изменения в .gitlab-ci.yml

![linux](./Sreen/screen29.png)

- значение when равное manual означает, что задача не будет запускаться автоматически в рамках пайплайна. Вместо этого она будет ожидать ручного запуска через пользовательский интерфейс GitLab.

5) Запускаем пайплан и убеждаемся что все работает как надо

![linux](./Sreen/screen30.png)

![linux](./Sreen/screen31.png)

![linux](./Sreen/screen32.png)

![linux](./Sreen/screen33.png)